//
//  kpFraction.m
//  kpFractionTest
//
//  Created by knax on 6/30/16.
//  Copyright Â© 2016 StepwiseDesigns. All rights reserved.
//


#import "kpFraction.h"

@implementation kpFraction
/* @synthesize replaces all commented code and allows you to name the variable instances.  if @synthesize is not used instanace variable names are preFixed with an _undersScore. 
    NOTE: methods definations are auto generated by the complier and not shown in file */

@synthesize numerator, denominator;
//    {
//    int numerator;
//    int denominator;
//    }


/* replaced by @synthesize above 1 line of code for methods vs 8 lines old way */
 
//-(void) setNumerator: (int) n{
//    numerator = n;
//}
//-(void) setDenominator: (int) d{
//    denominator = d;
//}
//-(int) numerator {
//    return numerator;
//}
//
//-(int) denominator{
//    return denominator;
//}

-(void) print{
    if (_wholeNumber != 0)
    NSLog(@"%i %i / %i",_wholeNumber, numerator, denominator);
    
    else
        NSLog(@"%i / %i",numerator, denominator);
}


-(double) convertToNum {
    if (denominator != 0)
        return (double) numerator / denominator;
    else
        return NAN;
}

-(void) setTo: (int) n over: (int)d
{
    numerator = n;
    denominator = d;
}

-(kpFraction *) add: (kpFraction *) f{
    //new fraction instance to store result of addition
    kpFraction *results = [[kpFraction alloc]init];
    
    results.numerator = numerator * f.denominator + denominator * f.numerator;
    results.denominator = denominator * f.denominator;
    [results reduce];
    return results;

}

-(void) reduce{
    int u = numerator;
    int v = denominator;
    int temp;
    
    while (v != 0){
        temp = u % v;
        u = v;
        v = temp;
    }
    numerator /= u;
    denominator /= u;
    
    if (numerator > denominator){

        _wholeNumber = numerator/denominator;
        numerator = numerator % denominator;
    }

    
    
    }
-(kpFraction *) subtract: (kpFraction *) s{
    kpFraction *sFraction = [[kpFraction alloc] init];
    
    sFraction.numerator = numerator * s.denominator - denominator * s.numerator;
    sFraction.denominator = (denominator * s.denominator);
    [sFraction reduce];
    [sFraction print];
    
    return sFraction;

}

-(kpFraction *) multiply: (kpFraction *) m{
    kpFraction *multiResult = [[kpFraction alloc] init];
    
    multiResult.numerator = numerator * m.numerator;
    multiResult.denominator = denominator * m.denominator;
    [multiResult reduce];
    return multiResult;
    
}
    
-(kpFraction *) divide: (kpFraction *) d{
    kpFraction *divResult = [[kpFraction alloc]init];
    
    divResult.numerator = numerator * d.denominator;
    divResult.denominator = denominator * d.numerator;
    [divResult reduce];
    return divResult;
    
}


@end


