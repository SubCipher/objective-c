//
//  kpFraction.m
//  kpFractionTest
//
//  Created by knax on 6/30/16.
//  Copyright Â© 2016 StepwiseDesigns. All rights reserved.
//


#import "kpFraction.h"


static int gCounter;


@implementation kpFraction
/* @synthesize replaces all commented code and allows you to name the variable instances.  if @synthesize is not used instanace variable names are preFixed with an _undersScore. 
    NOTE: methods definations are auto generated by the complier and not shown in file */

@synthesize numerator, denominator;

+(kpFraction *) allocF
  {
      extern int gCounter;
      ++gCounter;
      return [kpFraction alloc];
  }

+(int) count{
    extern int gCounter;
    return gCounter;
}




-(void) print{
    if (_wholeNumber != 0)
    NSLog(@"%i %i / %i",_wholeNumber, numerator, denominator);
    
    else
        NSLog(@"%i / %i",numerator, denominator);
}


-(double) convertToNum {
    if (denominator != 0)
        return (double) numerator / denominator;
    else
        return NAN;
}

-(void) setTo: (int) n over: (int)d
{
    numerator = n;
    denominator = d;
}

-(kpFraction *) add: (kpFraction *) f{
    //new fraction instance to store result of addition
    kpFraction *results = [[kpFraction alloc]init];
    
    results.numerator = numerator * f.denominator + denominator * f.numerator;
    results.denominator = denominator * f.denominator;
    [results reduce];
    return results;

}

-(void) reduce{
    int u = numerator;
    int v = denominator;
    int temp;
    
    while (v != 0){
        temp = u % v;
        u = v;
        v = temp;
    }
    numerator /= u;
    denominator /= u;
    
    if (numerator > denominator){

        _wholeNumber = numerator/denominator;
        numerator = numerator % denominator;
    }

    
    
    }
-(kpFraction *) subtract: (kpFraction *) s{
    kpFraction *sFraction = [[kpFraction alloc] init];
    
    sFraction.numerator = numerator * s.denominator - denominator * s.numerator;
    sFraction.denominator = (denominator * s.denominator);
    [sFraction reduce];
    [sFraction print];
    
    return sFraction;

}

-(kpFraction *) multiply: (kpFraction *) m{
    kpFraction *multiResult = [[kpFraction alloc] init];
    
    multiResult.numerator = numerator * m.numerator;
    multiResult.denominator = denominator * m.denominator;
    [multiResult reduce];
    return multiResult;
    
}
    
-(kpFraction *) divide: (kpFraction *) d{
    kpFraction *divResult = [[kpFraction alloc]init];
    
    divResult.numerator = numerator * d.denominator;
    divResult.denominator = denominator * d.numerator;
    [divResult reduce];
    return divResult;
    
}


@end


